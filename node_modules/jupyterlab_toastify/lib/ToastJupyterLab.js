import * as React from "react";
import { ToastContainer, toast, Slide } from "react-toastify";
/**
 * React component that will contains all toast produced through INotification
 */
export class LabToastContainer extends React.Component {
    render() {
        return (React.createElement(ToastContainer, { draggable: false, closeOnClick: false, hideProgressBar: true, newestOnTop: true, position: "bottom-right", className: "jp-toastContainer", transition: Slide }));
    }
}
export var INotification;
(function (INotification) {
    /** Create a button with customized callback in a toast */
    const ToastButton = ({ button, closeToast }) => {
        let fullClassName = button.className === undefined
            ? "jp-toast-button"
            : "jp-toast-button " + button.className;
        const clickHandler = () => {
            closeToast();
            button.callback();
        };
        return (React.createElement("button", { className: fullClassName, onClick: clickHandler }, button.label));
    };
    /**
     * Helper function to construct the notification content
     *
     * @param message Message to print in the notification
     * @param closeHandler Function closing the notification
     * @param options Notification options
     */
    function createToast(message, closeHandler, options) {
        if (options !== undefined &&
            options.buttons !== undefined &&
            options.buttons.length > 0) {
            return (React.createElement("div", null,
                message,
                React.createElement("div", { className: "jp-toast-buttonBar" },
                    React.createElement("div", { className: "jp-toast-spacer" }),
                    options.buttons.map((button, idx) => {
                        return (React.createElement(ToastButton, { key: "button-" + idx, button: button, closeToast: closeHandler }));
                    }))));
        }
        else {
            return React.createElement("div", null, message);
        }
    }
    /**
     * Helper function to show an error notification. Those
     * notifications need an user action to close.
     *
     * @param message Message to be printed in the notification
     * @param options Options for the error notification
     */
    INotification.error = (message, options) => toast(({ closeToast }) => createToast(message, closeToast, options), {
        type: "error",
        className: "jp-toast-error",
        autoClose: false
    });
    /**
     * Helper function to show a warning notification. Those
     * notifications need an user action to close.
     *
     * @param message Message to be printed in the notification
     * @param options Options for the warning notification
     */
    INotification.warning = (message, options) => toast(({ closeToast }) => createToast(message, closeToast, options), {
        type: "warning",
        className: "jp-toast-warning",
        autoClose: false
    });
    /**
     * Helper function to show an informative notification. Those
     * notifications close automatically.
     *
     * @param message Message to be printed in the notification
     * @param options Options for the error notification
     */
    INotification.info = (message, options) => {
        let autoClose = options && options.buttons.length > 0 ? false : undefined;
        return toast(({ closeToast }) => createToast(message, closeToast, options), {
            type: "info",
            className: "jp-toast-info",
            autoClose: autoClose
        });
    };
    /**
     * Helper function to show a success notification. Those
     * notifications close automatically.
     *
     * @param message Message to be printed in the notification
     * @param options Options for the error notification
     */
    INotification.success = (message, options) => {
        let autoClose = options && options.buttons.length > 0 ? false : undefined;
        return toast(({ closeToast }) => createToast(message, closeToast, options), {
            type: "success",
            className: "jp-toast-success",
            autoClose: autoClose
        });
    };
    /**
     * Helper function to show a in progress notification. Those
     * notifications do not close automatically.
     *
     * @param message Message to be printed in the notification
     * @param options Options for the error notification
     */
    INotification.inProgress = (message, options) => toast(({ closeToast }) => createToast(message, closeToast, options), {
        type: "default",
        className: "jp-toast-inprogress",
        autoClose: false
    });
    /**
     * Update an existing toast.
     *
     * If the toast is inactive (i.e. closed), a new one with the provided id
     * will be created with the new content.
     *
     * @param args Update options
     */
    INotification.update = function (args) {
        let autoClose = args.buttons && args.buttons.length > 0
            ? args.autoClose || false
            : args.autoClose;
        const closeToast = () => {
            toast.dismiss(args.toastId);
        };
        let options = {
            render: createToast(args.message, closeToast, { buttons: args.buttons })
        };
        if (args.type)
            options.type = args.type;
        if (autoClose) {
            options.autoClose = autoClose;
        }
        if (toast.isActive(args.toastId)) {
            // Update existing toast
            toast.update(args.toastId, options);
        }
        else {
            // Needs to recreate a closed toast
            options.toastId = args.toastId;
            if (!options.type) {
                // If not type specifed, assumes it is `in progress`
                options = Object.assign(Object.assign({}, options), { type: "default", className: "jp-toast-inprogress", autoClose: false });
            }
            toast(options.render, options);
        }
    };
    /**
     * Dismiss one toast (specified by its id) or all if no id provided
     *
     * @param toastId Toast id
     */
    INotification.dismiss = (toastId) => {
        toast.dismiss(toastId);
    };
    /**
     * Proxy to `toast` function from `react-toastify` module
     *
     * @param content Toast content
     * @param options Toast creation option
     */
    INotification.notify = (content, options) => toast(content, options);
})(INotification || (INotification = {}));
