{"version":3,"names":["Private","Application","options","this","_started","_pluginMap","createPluginMap","_serviceMap","createServiceMap","_delegate","PromiseDelegate","commands","CommandRegistry","renderer","contextMenuRenderer","contextMenu","ContextMenu","commands$1","shell","Object","defineProperty","prototype","promise","hasPlugin","id","listPlugins","keys","registerPlugin","plugin","Error","data","createPluginData","ensureNoCycle","provides","set","registerPlugins","plugins","_i","plugins_1","length","activatePlugin","_this","Promise","reject","activated","resolve","undefined","required","requires","map","t","resolveRequiredService","optional","resolveOptionalService","promises","concat","all","then","services","activate","apply","s","i","il","arguments","r","Array","k","a","j","jl","__spreadArrays","service","catch","error","token","get","name","reason","console","start","hostID","collectStartupPlugins","attachShell","addEventListeners","handleEvent","event","type","evtResize","evtKeydown","evtContextMenu","Widget","attach","document","getElementById","body","addEventListener","window","processKeydownEvent","shiftKey","open","preventDefault","stopPropagation","update","create","Map","autoStart","slice","pluginMap","serviceMap","dependencies","trace","some","visit","other","otherDependencies","push","pop","join","resultMap","startPlugins","_a","ignorePlugins","_b","_c"],"sources":["../src/index.ts","../node_modules/tslib/tslib.es6.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { CommandRegistry } from '@lumino/commands';\n\nimport { PromiseDelegate, Token } from '@lumino/coreutils';\n\nimport { ContextMenu, Menu, Widget } from '@lumino/widgets';\n\n/**\n * A user-defined application plugin.\n *\n * #### Notes\n * Plugins are the foundation for building an extensible application.\n *\n * Plugins consume and provide \"services\", which are nothing more than\n * concrete implementations of interfaces and/or abstract types.\n *\n * Unlike regular imports and exports, which tie the service consumer\n * to a particular implementation of the service, plugins decouple the\n * service producer from the service consumer, allowing an application\n * to be easily customized by third parties in a type-safe fashion.\n */\nexport interface IPlugin<T, U> {\n  /**\n   * The human readable id of the plugin.\n   *\n   * #### Notes\n   * This must be unique within an application.\n   */\n  id: string;\n\n  /**\n   * Whether the plugin should be activated on application start.\n   *\n   * #### Notes\n   * The default is `false`.\n   */\n  autoStart?: boolean;\n\n  /**\n   * The types of required services for the plugin, if any.\n   *\n   * #### Notes\n   * These tokens correspond to the services that are required by\n   * the plugin for correct operation.\n   *\n   * When the plugin is activated, a concrete instance of each type\n   * will be passed to the `activate()` function, in the order they\n   * are specified in the `requires` array.\n   */\n  requires?: Token<any>[];\n\n  /**\n   * The types of optional services for the plugin, if any.\n   *\n   * #### Notes\n   * These tokens correspond to the services that can be used by the\n   * plugin if available, but are not necessarily required.\n   *\n   * The optional services will be passed to the `activate()` function\n   * following all required services. If an optional service cannot be\n   * resolved, `null` will be passed in its place.\n   */\n  optional?: Token<any>[];\n\n  /**\n   * The type of service provided by the plugin, if any.\n   *\n   * #### Notes\n   * This token corresponds to the service exported by the plugin.\n   *\n   * When the plugin is activated, the return value of `activate()`\n   * is used as the concrete instance of the type.\n   */\n  provides?: Token<U>;\n\n  /**\n   * A function invoked to activate the plugin.\n   *\n   * @param app - The application which owns the plugin.\n   *\n   * @param args - The services specified by the `requires` property.\n   *\n   * @returns The provided service, or a promise to the service.\n   *\n   * #### Notes\n   * This function will be called whenever the plugin is manually\n   * activated, or when another plugin being activated requires\n   * the service it provides.\n   *\n   * This function will not be called unless all of its required\n   * services can be fulfilled.\n   */\n  activate: (app: T, ...args: any[]) => U | Promise<U>;\n}\n\n/**\n * A class for creating pluggable applications.\n *\n * #### Notes\n * The `Application` class is useful when creating large, complex\n * UI applications with the ability to be safely extended by third\n * party code via plugins.\n */\nexport class Application<T extends Widget> {\n  /**\n   * Construct a new application.\n   *\n   * @param options - The options for creating the application.\n   */\n  constructor(options: Application.IOptions<T>) {\n    // Create the application command registry.\n    let commands = new CommandRegistry();\n\n    // Create the application context menu.\n    let renderer = options.contextMenuRenderer;\n    let contextMenu = new ContextMenu({ commands, renderer });\n\n    // Initialize the application state.\n    this.commands = commands;\n    this.contextMenu = contextMenu;\n    this.shell = options.shell;\n  }\n\n  /**\n   * The application command registry.\n   */\n  readonly commands: CommandRegistry;\n\n  /**\n   * The application context menu.\n   */\n  readonly contextMenu: ContextMenu;\n\n  /**\n   * The application shell widget.\n   *\n   * #### Notes\n   * The shell widget is the root \"container\" widget for the entire\n   * application. It will typically expose an API which allows the\n   * application plugins to insert content in a variety of places.\n   */\n  readonly shell: T;\n\n  /**\n   * A promise which resolves after the application has started.\n   *\n   * #### Notes\n   * This promise will resolve after the `start()` method is called,\n   * when all the bootstrapping and shell mounting work is complete.\n   */\n  get started(): Promise<void> {\n    return this._delegate.promise;\n  }\n\n  /**\n   * Test whether a plugin is registered with the application.\n   *\n   * @param id - The id of the plugin of interest.\n   *\n   * @returns `true` if the plugin is registered, `false` otherwise.\n   */\n  hasPlugin(id: string): boolean {\n    return id in this._pluginMap;\n  }\n\n  /**\n   * List the IDs of the plugins registered with the application.\n   *\n   * @returns A new array of the registered plugin IDs.\n   */\n  listPlugins(): string[] {\n    return Object.keys(this._pluginMap);\n  }\n\n  /**\n   * Register a plugin with the application.\n   *\n   * @param plugin - The plugin to register.\n   *\n   * #### Notes\n   * An error will be thrown if a plugin with the same id is already\n   * registered, or if the plugin has a circular dependency.\n   *\n   * If the plugin provides a service which has already been provided\n   * by another plugin, the new service will override the old service.\n   */\n  registerPlugin(plugin: IPlugin<this, any>): void {\n    // Throw an error if the plugin id is already registered.\n    if (plugin.id in this._pluginMap) {\n      throw new Error(`Plugin '${plugin.id}' is already registered.`);\n    }\n\n    // Create the normalized plugin data.\n    let data = Private.createPluginData(plugin);\n\n    // Ensure the plugin does not cause a cyclic dependency.\n    Private.ensureNoCycle(data, this._pluginMap, this._serviceMap);\n\n    // Add the service token to the service map.\n    if (data.provides) {\n      this._serviceMap.set(data.provides, data.id);\n    }\n\n    // Add the plugin to the plugin map.\n    this._pluginMap[data.id] = data;\n  }\n\n  /**\n   * Register multiple plugins with the application.\n   *\n   * @param plugins - The plugins to register.\n   *\n   * #### Notes\n   * This calls `registerPlugin()` for each of the given plugins.\n   */\n  registerPlugins(plugins: IPlugin<this, any>[]): void {\n    for (let plugin of plugins) {\n      this.registerPlugin(plugin);\n    }\n  }\n\n  /**\n   * Activate the plugin with the given id.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @returns A promise which resolves when the plugin is activated\n   *   or rejects with an error if it cannot be activated.\n   */\n  activatePlugin(id: string): Promise<void> {\n    // Reject the promise if the plugin is not registered.\n    let data = this._pluginMap[id];\n    if (!data) {\n      return Promise.reject(new Error(`Plugin '${id}' is not registered.`));\n    }\n\n    // Resolve immediately if the plugin is already activated.\n    if (data.activated) {\n      return Promise.resolve(undefined);\n    }\n\n    // Return the pending resolver promise if it exists.\n    if (data.promise) {\n      return data.promise;\n    }\n\n    // Resolve the required services for the plugin.\n    let required = data.requires.map(t => this.resolveRequiredService(t));\n\n    // Resolve the optional services for the plugin.\n    let optional = data.optional.map(t => this.resolveOptionalService(t));\n\n    // Create the array of promises to resolve.\n    let promises = required.concat(optional);\n\n    // Setup the resolver promise for the plugin.\n    data.promise = Promise.all(promises)\n      .then(services => {\n        return data.activate.apply(undefined, [this, ...services]);\n      })\n      .then(service => {\n        data.service = service;\n        data.activated = true;\n        data.promise = null;\n      })\n      .catch(error => {\n        data.promise = null;\n        throw error;\n      });\n\n    // Return the pending resolver promise.\n    return data.promise;\n  }\n\n  /**\n   * Resolve a required service of a given type.\n   *\n   * @param token - The token for the service type of interest.\n   *\n   * @returns A promise which resolves to an instance of the requested\n   *   service, or rejects with an error if it cannot be resolved.\n   *\n   * #### Notes\n   * Services are singletons. The same instance will be returned each\n   * time a given service token is resolved.\n   *\n   * If the plugin which provides the service has not been activated,\n   * resolving the service will automatically activate the plugin.\n   *\n   * User code will not typically call this method directly. Instead,\n   * the required services for the user's plugins will be resolved\n   * automatically when the plugin is activated.\n   */\n  resolveRequiredService<U>(token: Token<U>): Promise<U> {\n    // Reject the promise if there is no provider for the type.\n    let id = this._serviceMap.get(token);\n    if (!id) {\n      return Promise.reject(new Error(`No provider for: ${token.name}.`));\n    }\n\n    // Resolve immediately if the plugin is already activated.\n    let data = this._pluginMap[id];\n    if (data.activated) {\n      return Promise.resolve(data.service);\n    }\n\n    // Otherwise, activate the plugin and wait on the results.\n    return this.activatePlugin(id).then(() => data.service);\n  }\n\n  /**\n   * Resolve an optional service of a given type.\n   *\n   * @param token - The token for the service type of interest.\n   *\n   * @returns A promise which resolves to an instance of the requested\n   *   service, or `null` if it cannot be resolved.\n   *\n   * #### Notes\n   * Services are singletons. The same instance will be returned each\n   * time a given service token is resolved.\n   *\n   * If the plugin which provides the service has not been activated,\n   * resolving the service will automatically activate the plugin.\n   *\n   * User code will not typically call this method directly. Instead,\n   * the optional services for the user's plugins will be resolved\n   * automatically when the plugin is activated.\n   */\n  resolveOptionalService<U>(token: Token<U>): Promise<U | null> {\n    // Resolve with `null` if there is no provider for the type.\n    let id = this._serviceMap.get(token);\n    if (!id) {\n      return Promise.resolve(null);\n    }\n\n    // Resolve immediately if the plugin is already activated.\n    let data = this._pluginMap[id];\n    if (data.activated) {\n      return Promise.resolve(data.service);\n    }\n\n    // Otherwise, activate the plugin and wait on the results.\n    return this.activatePlugin(id)\n      .then(() => {\n        return data.service;\n      })\n      .catch(reason => {\n        console.error(reason);\n        return null;\n      });\n  }\n\n  /**\n   * Start the application.\n   *\n   * @param options - The options for starting the application.\n   *\n   * @returns A promise which resolves when all bootstrapping work\n   *   is complete and the shell is mounted to the DOM.\n   *\n   * #### Notes\n   * This should be called once by the application creator after all\n   * initial plugins have been registered.\n   *\n   * If a plugin fails to the load, the error will be logged and the\n   * other valid plugins will continue to be loaded.\n   *\n   * Bootstrapping the application consists of the following steps:\n   * 1. Activate the startup plugins\n   * 2. Wait for those plugins to activate\n   * 3. Attach the shell widget to the DOM\n   * 4. Add the application event listeners\n   */\n  start(options: Application.IStartOptions = {}): Promise<void> {\n    // Return immediately if the application is already started.\n    if (this._started) {\n      return this._delegate.promise;\n    }\n\n    // Mark the application as started;\n    this._started = true;\n\n    // Parse the host id for attaching the shell.\n    let hostID = options.hostID || '';\n\n    // Collect the ids of the startup plugins.\n    let startups = Private.collectStartupPlugins(this._pluginMap, options);\n\n    // Generate the activation promises.\n    let promises = startups.map(id => {\n      return this.activatePlugin(id).catch(error => {\n        console.error(`Plugin '${id}' failed to activate.`);\n        console.error(error);\n      });\n    });\n\n    // Wait for the plugins to activate, then finalize startup.\n    Promise.all(promises).then(() => {\n      this.attachShell(hostID);\n      this.addEventListeners();\n      this._delegate.resolve(undefined);\n    });\n\n    // Return the pending delegate promise.\n    return this._delegate.promise;\n  }\n\n  /**\n   * Handle the DOM events for the application.\n   *\n   * @param event - The DOM event sent to the application.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events registered for the application. It\n   * should not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'resize':\n        this.evtResize(event);\n        break;\n      case 'keydown':\n        this.evtKeydown(event as KeyboardEvent);\n        break;\n      case 'contextmenu':\n        this.evtContextMenu(event as MouseEvent);\n        break;\n    }\n  }\n\n  /**\n   * Attach the application shell to the DOM.\n   *\n   * @param id - The id of the host node for the shell, or `''`.\n   *\n   * #### Notes\n   * If the id is not provided, the document body will be the host.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected attachShell(id: string): void {\n    Widget.attach(\n      this.shell,\n      (id && document.getElementById(id)) || document.body\n    );\n  }\n\n  /**\n   * Add the application event listeners.\n   *\n   * #### Notes\n   * The default implementation of this method adds listeners for\n   * `'keydown'` and `'resize'` events.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected addEventListeners(): void {\n    document.addEventListener('contextmenu', this);\n    document.addEventListener('keydown', this, true);\n    window.addEventListener('resize', this);\n  }\n\n  /**\n   * A method invoked on a document `'keydown'` event.\n   *\n   * #### Notes\n   * The default implementation of this method invokes the key down\n   * processing method of the application command registry.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected evtKeydown(event: KeyboardEvent): void {\n    this.commands.processKeydownEvent(event);\n  }\n\n  /**\n   * A method invoked on a document `'contextmenu'` event.\n   *\n   * #### Notes\n   * The default implementation of this method opens the application\n   * `contextMenu` at the current mouse position.\n   *\n   * If the application context menu has no matching content *or* if\n   * the shift key is pressed, the default browser context menu will\n   * be opened instead.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected evtContextMenu(event: MouseEvent): void {\n    if (event.shiftKey) {\n      return;\n    }\n    if (this.contextMenu.open(event)) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n\n  /**\n   * A method invoked on a window `'resize'` event.\n   *\n   * #### Notes\n   * The default implementation of this method updates the shell.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected evtResize(event: Event): void {\n    this.shell.update();\n  }\n\n  private _started = false;\n  private _pluginMap = Private.createPluginMap();\n  private _serviceMap = Private.createServiceMap();\n  private _delegate = new PromiseDelegate<void>();\n}\n\n/**\n * The namespace for the `Application` class statics.\n */\nexport namespace Application {\n  /**\n   * An options object for creating an application.\n   */\n  export interface IOptions<T extends Widget> {\n    /**\n     * The shell widget to use for the application.\n     *\n     * This should be a newly created and initialized widget.\n     *\n     * The application will attach the widget to the DOM.\n     */\n    shell: T;\n\n    /**\n     * A custom renderer for the context menu.\n     */\n    contextMenuRenderer?: Menu.IRenderer;\n  }\n\n  /**\n   * An options object for application startup.\n   */\n  export interface IStartOptions {\n    /**\n     * The ID of the DOM node to host the application shell.\n     *\n     * #### Notes\n     * If this is not provided, the document body will be the host.\n     */\n    hostID?: string;\n\n    /**\n     * The plugins to activate on startup.\n     *\n     * #### Notes\n     * These will be *in addition* to any `autoStart` plugins.\n     */\n    startPlugins?: string[];\n\n    /**\n     * The plugins to **not** activate on startup.\n     *\n     * #### Notes\n     * This will override `startPlugins` and any `autoStart` plugins.\n     */\n    ignorePlugins?: string[];\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * An object which holds the full application state for a plugin.\n   */\n  export interface IPluginData {\n    /**\n     * The human readable id of the plugin.\n     */\n    readonly id: string;\n\n    /**\n     * Whether the plugin should be activated on application start.\n     */\n    readonly autoStart: boolean;\n\n    /**\n     * The types of required services for the plugin, or `[]`.\n     */\n    readonly requires: Token<any>[];\n\n    /**\n     * The types of optional services for the the plugin, or `[]`.\n     */\n    readonly optional: Token<any>[];\n\n    /**\n     * The type of service provided by the plugin, or `null`.\n     */\n    readonly provides: Token<any> | null;\n\n    /**\n     * The function which activates the plugin.\n     */\n    readonly activate: (app: any, ...args: any[]) => any;\n\n    /**\n     * Whether the plugin has been activated.\n     */\n    activated: boolean;\n\n    /**\n     * The resolved service for the plugin, or `null`.\n     */\n    service: any | null;\n\n    /**\n     * The pending resolver promise, or `null`.\n     */\n    promise: Promise<void> | null;\n  }\n\n  /**\n   * A type alias for a mapping of plugin id to plugin data.\n   */\n  export type PluginMap = { [id: string]: IPluginData };\n\n  /**\n   * A type alias for a mapping of service token to plugin id.\n   */\n  export type ServiceMap = Map<Token<any>, string>;\n\n  /**\n   * Create a new plugin map.\n   */\n  export function createPluginMap(): PluginMap {\n    return Object.create(null);\n  }\n\n  /**\n   * Create a new service map.\n   */\n  export function createServiceMap(): ServiceMap {\n    return new Map<Token<any>, string>();\n  }\n\n  /**\n   * Create a normalized plugin data object for the given plugin.\n   */\n  export function createPluginData(plugin: IPlugin<any, any>): IPluginData {\n    return {\n      id: plugin.id,\n      service: null,\n      promise: null,\n      activated: false,\n      activate: plugin.activate,\n      provides: plugin.provides || null,\n      autoStart: plugin.autoStart || false,\n      requires: plugin.requires ? plugin.requires.slice() : [],\n      optional: plugin.optional ? plugin.optional.slice() : []\n    };\n  }\n\n  /**\n   * Ensure no cycle is present in the plugin resolution graph.\n   *\n   * If a cycle is detected, an error will be thrown.\n   */\n  export function ensureNoCycle(\n    data: IPluginData,\n    pluginMap: PluginMap,\n    serviceMap: ServiceMap\n  ): void {\n    let dependencies = data.requires.concat(data.optional);\n    // Bail early if there cannot be a cycle.\n    if (!data.provides || dependencies.length === 0) {\n      return;\n    }\n\n    // Setup a stack to trace service resolution.\n    let trace = [data.id];\n\n    // Throw an exception if a cycle is present.\n    if (dependencies.some(visit)) {\n      throw new Error(`Cycle detected: ${trace.join(' -> ')}.`);\n    }\n\n    function visit(token: Token<any>): boolean {\n      if (token === data.provides) {\n        return true;\n      }\n      let id = serviceMap.get(token);\n      if (!id) {\n        return false;\n      }\n      let other = pluginMap[id];\n      let otherDependencies = other.requires.concat(other.optional);\n      if (otherDependencies.length === 0) {\n        return false;\n      }\n      trace.push(id);\n      if (otherDependencies.some(visit)) {\n        return true;\n      }\n      trace.pop();\n      return false;\n    }\n  }\n\n  /**\n   * Collect the IDs of the plugins to activate on startup.\n   */\n  export function collectStartupPlugins(\n    pluginMap: PluginMap,\n    options: Application.IStartOptions\n  ): string[] {\n    // Create a map to hold the plugin IDs.\n    let resultMap: { [id: string]: boolean } = Object.create(null);\n\n    // Collect the auto-start plugins.\n    for (let id in pluginMap) {\n      if (pluginMap[id].autoStart) {\n        resultMap[id] = true;\n      }\n    }\n\n    // Add the startup plugins.\n    if (options.startPlugins) {\n      for (let id of options.startPlugins) {\n        resultMap[id] = true;\n      }\n    }\n\n    // Remove the ignored plugins.\n    if (options.ignorePlugins) {\n      for (let id of options.ignorePlugins) {\n        delete resultMap[id];\n      }\n    }\n\n    // Return the final startup plugins.\n    return Object.keys(resultMap);\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || from);\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n"],"mappings":"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"}